<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tuple · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Les tuples sont comme des tableaux JavaScript :"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Tuple · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="Les tuples sont comme des tableaux JavaScript :"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/tuple">日本語</a></li><li><a href="/docs/en/tuple">English</a></li><li><a href="/docs/de/tuple">Deutsch</a></li><li><a href="/docs/es-ES/tuple">Español</a></li><li><a href="/docs/ko/tuple">한국어</a></li><li><a href="/docs/pt-BR/tuple">Português (Brasil)</a></li><li><a href="/docs/ru/tuple">Русский</a></li><li><a href="/docs/uk/tuple">Українська</a></li><li><a href="/docs/zh-CN/tuple">中文</a></li><li><a href="/docs/zh-TW/tuple">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Principes de base du langage</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/primitives">Primitives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Records</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">Listes &amp; Tableaux</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/recursion">Recursion</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutable-bindings">Mutable Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Tuple</h1></header><article><div><span><p>Les tuples sont comme des tableaux JavaScript :</p>
<ul>
<li>ordered collection of items</li>
<li><strong>compiler vers des tableaux Javascript</strong></li>
</ul>
<p>Mais du côté de Reason, ils sont différents des tableaux. Ils sont:</p>
<ul>
<li>immuables</li>
<li>de taille fixe dès la création</li>
<li>hétérogènes (peuvent contenir des valeurs de types différents)</li>
</ul>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-356-tab-357" class="nav-link active" data-group="group_356" data-tab="tab-group-356-content-357">Reason</div><div id="tab-group-356-tab-358" class="nav-link" data-group="group_356" data-tab="tab-group-356-content-358">Output</div></div><div class="tab-content"><div id="tab-group-356-content-357" class="tab-pane active" data-group="group_356" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> ageAndName = (<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>);<br /><span class="hljs-keyword">let</span> my3dCoordinates = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /></code></pre>
</span></div></div><div id="tab-group-356-content-358" class="tab-pane" data-group="group_356" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> ageAndName = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>];<br /><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /></code></pre>
</span></div></div></div></div>
<p>Parce que les tuples se transforment en tableaux JavaScript, lorsque vous recevez un tableau JS existant du côté JS de votre codebase, vous pouvez également le modéliser comme un tuple du côté Reason, à condition que ce tableau ait les caractères ci-dessus (taille fixe, potentiellement hétérogène, etc.).</p>
<p>Comme partout dans Reason, vous n'avez pas besoin d'écrire la signature de type des tuples. Mais si vous le souhaitez, voici la syntaxe:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-359-tab-360" class="nav-link active" data-group="group_359" data-tab="tab-group-359-content-360">Reason</div><div id="tab-group-359-tab-361" class="nav-link" data-group="group_359" data-tab="tab-group-359-content-361">Output</div></div><div class="tab-content"><div id="tab-group-359-content-360" class="tab-pane active" data-group="group_359" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> ageAndName: (int, string) = (<span class="hljs-number">24</span>, <span class="hljs-string">"Lil' Reason"</span>);<br /><br /><span class="hljs-keyword">type</span> coord3d = (float, float, float); <span class="hljs-comment">/* a type alias for a tuple */</span><br /><span class="hljs-keyword">let</span> my3dCoordinates: coord3d = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /></code></pre>
</span></div></div><div id="tab-group-359-content-361" class="tab-pane" data-group="group_359" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> ageAndName = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>];<br /><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /></code></pre>
</span></div></div></div></div>
<p><strong>Note</strong> : il n'existe pas de tuple de taille 1. Vous utiliseriez directement la valeur elle-même.</p>
<h2><a class="anchor" aria-hidden="true" id="utilisation"></a><a href="#utilisation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utilisation</h2>
<p>Contrairement aux tableaux Reason et JS, vous n'accédez pas à un tuple via l'opérateur d'indexation, par exemple <code>myTuple[0]</code>. Généralement, vous avez accès aux éléments par le biais de la destructurations (décrit plus tard dans la barre latérale):</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-362-tab-363" class="nav-link active" data-group="group_362" data-tab="tab-group-362-content-363">Reason</div><div id="tab-group-362-tab-364" class="nav-link" data-group="group_362" data-tab="tab-group-362-content-364">Output</div></div><div class="tab-content"><div id="tab-group-362-content-363" class="tab-pane active" data-group="group_362" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> my3dCoordinates = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /><span class="hljs-keyword">let</span> (_, y, _) = my3dCoordinates; <span class="hljs-comment">/* now you've retrieved y */</span><br /></code></pre>
</span></div></div><div id="tab-group-362-content-364" class="tab-pane" data-group="group_362" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /><span class="hljs-keyword">var</span> y = <span class="hljs-number">30.5</span>;<br /></code></pre>
</span></div></div></div></div>
<p>Le <code>_</code> signifie que vous ignorez ces autres membres de la tuple.</p>
<p>C'est un peu gênant si vous accédez constamment à un élément d'un tuple (qui devrait être rare). Vous pouvez écrire votre propre fonction d'aide pour accéder au n-ième élément d'un tuple dans ce cas.</p>
<p>Les tuples ne sont pas censées être mises à jour de manière mutative; vous devriez plutôt retirer les valeurs pertinentes de l'ancien et les empiler dans une nouvelle tuple.</p>
<h2><a class="anchor" aria-hidden="true" id="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p>Vous utiliserez des tuples dans des situations pratiques qui transmettent plusieurs valeurs sans trop de cérémonie. Par exemple, pour renvoyer plusieurs valeurs :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> getCenterCoordinates = () =&gt; {
  <span class="hljs-keyword">let</span> x = doSomeOperationsHere();
  <span class="hljs-keyword">let</span> y = doSomeMoreOperationsHere();
  (x, y)
};
</code></pre>
<p>Ou pour &quot;pattern-match&quot; (traité plus loin) la conjonction des possibilités :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (isWindowOpen, isDoorOpen) { <span class="hljs-comment">/* this is a 2-tuple */</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>Essayez de garder l'utilisation de tuples <strong>locale</strong>. Pour les structures de données qui sont souvent utilisées, préférez un <strong>record</strong>, qui possède des noms de champs.</p>
<p>Un tuple pourrait aussi être appelé un &quot;type produit&quot;, et <code>(string, int)</code> est écrit <code>string * int</code> à certains endroits. L'idée est qu'un tuple est vraiment un &quot;produit cartésien&quot;. Imaginez une grille 2D, avec une <code>string</code> sur l'axe x et un <code>int</code> sur l'axe y !</p>
<p>Le combo tuple + <code>switch</code> est très puissant et concis, et <strong>supprime toute une catégorie de bugs</strong>. Ensemble, ils listent bien toutes les combinaisons possibles de valeurs. Un tuple de type <code>(bool, bool)</code> a en effet <code>2 * 2 = 4</code> possibilités, et le système de types vous demande de couvrir tous les 4. Cela se prête bien aux remaniements de codes; au lieu d'ajouter de manière informelle quelques if-else sur des valeurs arbitraires ici et là, vous pouvez directement pointer le <code>switch</code> exact que vous avez besoin de modifier, ni plus ni moins.</p>
<h2><a class="anchor" aria-hidden="true" id="decisions-de-conception"></a><a href="#decisions-de-conception" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Décisions de conception</h2>
<p>L'existence de tuples peut sembler étrange pour ceux qui viennent de langages non typés. &quot;Pourquoi ne pas utiliser tout simplement un tableau?&quot;</p>
<p>Un système de types n'est pas tout-puissant et ne devrait pas l'être ; quelques compromis de bon goût doivent être appliqués afin de garder le langage simple, performant (à la fois sur la compilation et la vitesse d'exécution) et facile à comprendre. Les lists Reason, par exemple, sont plus flexibles en taille. Elles peuvent être concaténées, ajoutées, tranchées, etc. En retour, elles doivent être homogènes (ne peuvent contenir qu'un seul type de valeur par list), et l'accès aléatoire à un index peut ne pas toujours être valide*. Le tuple, d'autre part, grâce à sa contrainte de taille, est plus rapide, donne au système de types assez de marge de manœuvre pour suivre de manière exhaustive tous les types de ses objets et garantit un accès sécurisé. En général, vous remarquerez quelques compromis importants et utiles dans un système de type : les champs de records sont fixes, mais peuvent être hétérogènes, alors que les champs d'une map sont flexibles mais homogènes, etc.</p>
<p>Un tuple Reason est typé &quot;structurellement&quot;. Cela signifie que même si vous n'avez pas annoté votre donnée avec un type explicite, le compilateur peut encore le déduire en regardant son contenu, son utilisation, etc. Tant que les déclarations et les formes inférées des usages correspondent, tout va bien !</p>
<p>* Ce n'est pas que le système de types Reason ne puisse pas accepter des listes hétérogènes et de taille dynamique ; il le peut en fait dans certaines circonstances, mais faire de cette fonctionnalité la valeur par défaut augmente à la fois la surcharge d'apprentissage et la compréhensibilité du code. Ce n'est pas parce que les types peuvent le faire que c'est toujours une bonne idée de laisser des morceaux de code grandir sans limites !</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/type"><span class="arrow-prev">← </span><span>Type !</span></a><a class="docs-next button" href="/docs/fr/record"><span>Records</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#utilisation">Utilisation</a></li><li><a href="#conseils-amp-astuces">Conseils &amp; astuces</a></li><li><a href="#decisions-de-conception">Décisions de conception</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>